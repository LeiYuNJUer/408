# OS-01 概论

## 1 引入与前置知识

### 1.1 和计组的关系

OS使用计组提供的硬件功能的抽象，不需要知道硬件功能如何实现；

利用底层硬件功能对资源进行一系列的处理、计算等，为上层应用程序提供服务，是一种软件。

### 1.2 计算机结构

![image-20220708173557991](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708173557991.png)

磁盘其实算作I/O，但这里分开讨论；

内存和磁盘以扇区为基本单位进行数据交换，这个功能的实现是硬件做的，在这里不需要继续讨论；

I/O设备通过里面的一些寄存器和一些存储空间，与内存进行数据交换（也可以把设备编址到内存中去）；

CPU有一些寄存器与内存可以进行数据交换，进行计算时，很难直接对内存的数据进行计算，需要先把数据移动到寄存器中，再通过数据通路进行数据的流动，此后才可以进行数据的计算和处理等工作；

我们的OS就是假设上述部件的功能已经实现了，我们来设计软件更好地管理他们。

### 1.3 程序的编译和链接

OS本身也是一个程序，它是如何从编译开始，之后又如何放到内存中去执行，这是我们需要研究的第一个问题

下面以C语言为例进行介绍：

假设某一个工程（一个大文件），它由几个小模块组成（主功能、其他的一些函数、变量等分开）

1. **预处理**：编程语言层面的工作，进行宏处理；

2. **编译**：每一个文件都会编译成一个汇编文件（注：编译有时候也可以一步到位，高级语言直接编译成机器语言）；

   ![image-20220708175522053](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708175522053.png)

3. **汇编**：每一个文件被汇编成机器语言；

   ![image-20220708175606907](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708175606907.png)

4. **链接**：由于多个模块的代码存在依赖关系，经过链接后，所有的模块合成了一个整体，我们有了整个模块的执行的入口、符号表（所有符号（函数、变量等）的定义），myproject.out是一个**可执行文件**（意味着我们可以把这个文件放进内存，CPU可以“跑动”它了）。

   ![image-20220708175637365](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708175637365.png)

### 1.4 程序的装载与执行

那么我们该如何将这个可执行文件装载到内存里，并执行它？

最初，我们的可执行文件放在磁盘当中（程序都是以文件的形式存放在磁盘中的），但我们想要执行它不可能在磁盘中执行，必须把它放到内存中去；

此时，又产生了新的问题，我们应该把这个可执行文件放在内存的哪个位置？

首先，可执行文件在物理层面上，它在磁盘中的存储形式不一定是连续的，很可能分布在若干个不连续的位置，但是，文件存在一个逻辑上的顺序，存在一个连续的逻辑空间；

同时，计算机访问一个程序时，需要把PC指向一个位置，我们如何确定这个位置？这个问题就是**重定位**，分为两种（动态重定位和静态重定位 ，在后续的内存管理部分，我们会有详细的解释）；

此外，为了确保我们可以访问到这个程序装载在内存的位置，我们需要为它提供**独立的**执行环境（包括寄存器组，ALU，状态字（PSW）等）；

![image-20220708182803345](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708182803345.png)

编译、链接后，可执行文件被划分为多个区域：

1. 堆栈：相向生长，esp寄存器指向栈顶地址。堆区是动态分配的区域（例如malloc）；栈区主要保存局部变量（保存函数返回地址、现场信息等时也会用到栈区）；
2. 全局变量：切分成两块：
   1. bss段：未初始化的全局变量；
   2. 数据段：初始化的全局变量；
3. 代码段：存放指令和只读常量（PC指向的就是代码段中的位置）

![image-20220708183446956](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708183446956.png)

### 1.5 理解OS的职能

#### 1.5.1 如何分配供给程序运行的内存？（内存管理）

![image-20220708183724958](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708183724958.png)

#### 1.5.2 在只有一个CPU的情况下，如何支持两个任务的并发执行？（进程管理，和内存管理有交叉，衍生出同步、互斥、死锁等问题）

![image-20220708183738694](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708183738694.png)

#### 1.5.3 不同的任务如何保证内存隔离？（内存管理）

![image-20220708184041677](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708184041677.png)

#### 1.5.4 如何重定位？（内存管理）

![image-20220708184154342](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708184154342.png)

#### 1.5.5 用户和进程通过文件名访问磁盘数据的时候，计算机如何精准地访问它在磁盘上的所有数据？（文件管理）

![image-20220708184604006](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708184604006.png)

#### 1.5.6 计算机如何抽象和管理I/O设备，为用户实现简易的I/O接口？（I/O管理）

![image-20220708184808081](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708184808081.png)

## 2 操作系统的地位

![image-20220708185211490](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708185211490.png)

## 3 操作系统软件的组成

![image-20220708185540765](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708185540765.png)

Shell、GUI运行在用户态、直接使用操作系统提供的功能

Kernel（内核）运行在核心态

## 4 操作系统内核特征

1. 并发：计算机系统中同时存在多个运行的程序，需要OS管理和调度，区别于并行；

   ![image-20220708185958225](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708185958225.png)

   ![image-20220708190016229](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708190016229.png)

2. 共享：“同时”访问；互斥共享；

3. 虚拟：利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务；

4. 异步：程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知；只要运行环境相同，OS需要保证程序运行的结果也要相同；

## 5 微内核结构

之前讨论的都是宏内核的结构，内核的所有功能都在内核里，如果需要，就向内核寻求服务；

微内核把一些内核功能放在用户态，看作一个进程；

![image-20220708190632071](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708190632071.png)

进程管理、进程通信等功能在内核态；

提高了安全性、稳定性；

由于不同进程之间存在内存隔离，不同模块间依靠IPC（进程间通信）来进行消息传递，速度比较慢，性能比较差；

## 6 操作系统的演变

1. 单用户系统

2. 批处理系统：与用户无交互且串行；

   ![image-20220708191430412](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708191430412.png)

3. 多道程序系统：

   多个工作在内存中，复用CPU、I/O时CPU让给其他进程使用

   ![image-20220708191621298](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708191621298.png)

4. 分时

   定时中断，用于对CPU的复用，依赖于时钟中断；

   ![image-20220708191722625](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708191722625.png)

5. 个人计算机：每个用户一个系统

6. 分布式计算（网络操作系统）：每个用户多个系统

   不同的功能模块分布在不同的机器上，通过网络传递数据结果，不同的机器协作完成同一个任务，需要一个操作系统在网络上管理所有的机器

   ![image-20220708191734156](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708191734156.png)

## 7 模块化程序设计

![image-20220708192146643](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708192146643.png)

1. 设计整个工程的方案，箭头表示申请服务；
2. 模块之间也会有相互的调用关系，但是模块内更具有整体性；
3. 独立性：模块完成独立的功能，与其他模块的联系应该尽可能得简单，各个模块具有相对独立性；
4. 模块的规模不能太大，也不能太小，如果模块的功能太强，可读性就会较差，若模块的功能太弱，就会有很多接口；
5. 注意对问题进行抽象化，模块化程序要注意层次化；

## 8 CPU的特权级

### 8.1 特权级作为一种硬件功能

一种硬件功能

CPU的某个引脚告诉我们的整个计算机，CPU目前处于什么状态

![image-20220708201536609](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708201536609.png)

每个进程都有一份操作系统代码，访问需要CPU处于内核态

![image-20220708201637072](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708201637072.png)

![image-20220708201802333](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708201802333.png)

**如何进入内核态？**依靠中断、异常机制

### 8.2 特权指令

一些特殊的指令，只有在内核态才能执行，用户态下会报错或异常

![image-20220708202235344](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708202235344.png)

1. 开关中断；
2. 存取特殊寄存器，例如页表寄存器、段基址寄存器；
3. 访问程序状态，即读PSW寄存器；
4. 控制I/O；

**用户如何才能使用内核的功能呢？**中断或异常（硬件功能，CPU提供的固有属性）；

![image-20220708202522810](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708202522810.png)

注：一个进程的用户空间和内核空间都会有一个栈，所以我们进行特权级切换的时候，不仅要进行一些其他的操作，我们还需要换栈；



![image-20220708202723222](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708202723222.png)

### 8.3 几个特殊的用户态指令/程序

#### 8.3.1 访管指令 = trap指令 = INT x

访管指令（或trap指令，或INT x 指令（表示触发x号软中断））：一个用户态程序想要主动地触发中断时，使用的一条指令，只能在用户态下使用

![image-20220708203046612](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708203046612.png)

#### 8.3.2 命令解释程序

![image-20220708203415742](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708203415742.png)

#### 8.3.3 GUI

![image-20220708203441695](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708203441695.png)

## 9 操作系统的装载

开机时操作系统如何被装载到内存中？

![image-20220708203904557](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708203904557.png)

BIOS写在内存的ROM上，断电不丢失；

BIOS的提供的四个功能：

1. 基本输入输出程序；
2. 系统设置信息；
3. 开机后自检程序；
4. 系统自启动程序；

BIOS的作用之一是将磁盘的**引导扇区**（实际上是第一个扇区，叫做主引导扇区 MBR）中的**加载程序**加载到内存中的某个位置（），PC指向这块内存的起始地址

加载程序将操作系统的代码和数据从磁盘加载到内存，并跳转到操作系统的起始位置

![image-20220708204541477](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708204541477.png)

![image-20220708204603231](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708204603231.png)

![image-20220708204751408](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708204751408.png)

## 10 中断和异常（重点）

![image-20220708204941830](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708204941830.png)

![image-20220708204959283](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708204959283.png)

408中，系统调用也是一种异常；

异常是CPU内部或者说是软件产生的，如INT x 或者 除0；

中断是来自硬件设备的处理请求，例如磁盘I/O请求、时钟中断；

中断又叫做外中断；异常又叫做内中断或软中断；

![image-20220708205240417](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708205240417.png)

![image-20220708205445755](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708205445755.png)

**中断处理机制**

CPU有一个引脚，专门接收中断，不同的中断有不同的信号；

IDTR寄存器指向中断向量表的位置，在中断周期中（计组知识），CPU检查是否收到中断，CPU一旦接收到k号中断，它会去中断向量表中查第k个向量，向量中存有服务地址，PC被赋值为服务地址；

以上过程都是硬件完成的；

![image-20220708210035920](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708210035920.png)

但是，其中的中断向量表是操作系统程序员来填写的；

同时，中断服务程序也是由操作系统程序员编写的；

![image-20220708210613087](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708210613087.png)

![image-20220708210715730](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708210715730.png)

![image-20220708210821659](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708210821659.png)

硬件处理阶段也叫**中断隐指令**；

关中断是为了断点能够被正常保存，防止中断嵌套发生时，断点丢失；（以及之后软件保存现场和屏蔽字可以顺利进行）

![image-20220708211008557](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708211008557.png)

跳转到中断服务程序后，中断服务程序的开始一定是保存现场和屏蔽字；

![image-20220708211445831](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708211445831.png)

第九步的“中断返回”代表了：

1. CPU从内核态重新回到了用户态；
2. 断点位置给到了PC；

![image-20220708211530793](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708211530793.png)

注：

1. “保存/恢复”前后需要关开中断；
2. 断点是“下一条指令”或者“这条指令”（如缺页异常）



**中断嵌套**

一定要到中断服务程序这个阶段，别的中断才有可能被允许进行嵌套，

![image-20220708212414506](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708212414506.png)



## 11 系统调用

系统调用是一种异常（或者叫软中断）

![image-20220708212559656](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708212559656.png)

![image-20220708212646086](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708212646086.png)

![image-20220708212842150](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708212842150.png)

注：以上这一部分虽然在用户态，但也是系统程序员编写的；

![image-20220708213131563](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708213131563.png)

![image-20220708213218963](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708213218963.png)

![image-20220708213230038](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708213230038.png)

“80”这个软中断号让内核知道我们触发的中断类型是系统调用；

系统调用号、参数和返回值利用寄存器进行传递；

![image-20220708213514658](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708213514658.png)

注：第三步可以进一步细分：

1. 查表；
2. 跳到对应的真正的系统调用服务程序；

![image-20220708213721952](OS-01%20%E6%A6%82%E8%AE%BA.assets/image-20220708213721952.png)

